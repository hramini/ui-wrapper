// Generated by dts-bundle-generator v4.0.0

export interface IBasicProperties<T> {
	key?: string | number;
	children?: (string | T)[];
}
export interface IBasicStates {
	key?: string;
}
export declare type PickState<S, K extends keyof S> = {
	[P in K]: S[P];
};
export interface IUnitLifeCycle {
	onBeforeProvide(): void;
	onAfterProvide(): void;
	onBeforeUpdate(): IUnitOnBeforeUpdateCheck;
	onAfterUpdate(): void;
	onBeforeDispose(): void;
}
export interface IUnit<T, P, S> extends IUnitLifeCycle {
	provide(): IElement<T>;
	forceUpdate(): void;
	alterState<K extends keyof S>(param: IUnitAlterStateOptions<S, K>): void;
	props: Readonly<P> & Readonly<IBasicProperties<T>>;
	state: Readonly<S>;
}
export interface IUnitAlterStateOptions<S, K extends keyof S> {
	state: PickState<S, K>;
	callbackFunction?: () => void;
}
export interface IUnitOnBeforeUpdateCheck {
	shouldUpdate: boolean;
}
export interface IElement<T> {
	element: T;
}
export interface IUnitSetPropertiesOptions<P> {
	properties: P;
}
export interface IElementOption<T, P, S> {
	name: string | (new () => IUnit<T, P, S>);
	properties: P;
	children?: (string | T)[];
}
export interface ITagElementOption<T, P, S> extends IElementOption<T, P, S> {
	name: string;
}
export interface IFrameElementOption<T, P, S> extends IElementOption<T, P, S> {
	name: new () => IUnit<T, P, S>;
}
export interface IBuilder<T> {
	buildElement<P, S>(elementOption: IElementOption<T, P, S>): IElement<T>;
}
export interface ITagBuilder<T> extends IBuilder<T> {
	buildElement<P, S>(elementOption: ITagElementOption<T, P, S>): IElement<T>;
}
export interface IFrameBuilder<T> extends IBuilder<T> {
	buildElement<P, S>(elementOption: IFrameElementOption<T, P, S>): IElement<T>;
}
export interface IBuilderSetTagBuilderIn<T> {
	tagBuilderClass: new () => ITagBuilder<T>;
}
export interface IBuilderSetFrameBuilderIn<T> {
	frameBuilderClass: new () => IFrameBuilder<T>;
}
export interface IBuilderGetTagBuilderOut<T> {
	tagBuilderInstance: ITagBuilder<T>;
}
export interface IBuilderGetFrameBuilderOut<T> {
	frameBuilderInstance: IFrameBuilder<T>;
}
export declare class Builder<T> implements IBuilder<T> {
	private static tagBuilderInstance;
	private static frameBuilderInstance;
	private readonly builder;
	private constructor();
	buildElement<P, S>(param: IElementOption<T, P, S>): IElement<T>;
	static setTagBuilder<K>(param: IBuilderSetTagBuilderIn<K>): void;
	static setFrameBuilder<K>(param: IBuilderSetFrameBuilderIn<K>): void;
	static getTagBuilder<K>(): IBuilderGetTagBuilderOut<K>;
	static getFrameBuilder<K>(): IBuilderGetFrameBuilderOut<K>;
}
export interface IPrimer<T> {
	element: T;
	target: HTMLElement;
	setElement(param: IPrimerElement<T>): void;
	setTarget(param: IPrimerTarget): void;
	start(): void;
}
export interface IPrimerEntry<T> {
	PrimerClass: new () => IPrimer<T>;
}
export interface IPrimerElement<T> {
	element: T;
}
export interface IPrimerTarget {
	target: HTMLElement;
}
export declare class Primer<T> {
	readonly entryPrimer: IPrimer<T>;
	constructor(entry: IPrimerEntry<T>);
	setElement(param: IPrimerElement<T>): void;
	setTarget(param: IPrimerTarget): void;
	start(): void;
}
export declare abstract class Unit<T, P, S> implements IUnit<T, P, S> {
	props: Readonly<P> & Readonly<IBasicProperties<T>>;
	state: Readonly<S>;
	forceUpdate(): void;
	alterState<K extends keyof S>(param: IUnitAlterStateOptions<S, K>): void;
	onBeforeProvide(): void;
	onAfterProvide(): void;
	onBeforeUpdate(): IUnitOnBeforeUpdateCheck;
	onAfterUpdate(): void;
	onBeforeDispose(): void;
	abstract provide(): IElement<T>;
}
export declare abstract class UnitFrame<T, P, S> extends Unit<T, P, S> {
	protected builder: IFrameBuilder<T>;
	constructor();
	protected buildElement<K, R>(param: IFrameElementOption<T, K, R>): IElement<T>;
}
export declare abstract class UnitTag<T, P, S> extends Unit<T, P, S> {
	protected builder: ITagBuilder<T>;
	constructor();
	protected buildElement<K, R>(param: ITagElementOption<T, K, R>): IElement<T>;
}

export {};
